/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.27.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import {HumanAddr, Uint128, StateMsg, Coin, State} from "./types";
import {ExecuteMsg, GetOwnerResponse, GetStateResponse, InstantiateMsg, QueryMsg} from "./DsourceEmpty.types";
export interface DsourceEmptyReadOnlyInterface {
  contractAddress: string;
  getState: () => Promise<GetStateResponse>;
  getOwner: () => Promise<GetOwnerResponse>;
}
export class DsourceEmptyQueryClient implements DsourceEmptyReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getState = this.getState.bind(this);
    this.getOwner = this.getOwner.bind(this);
  }

  getState = async (): Promise<GetStateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_state: {}
    });
  };
  getOwner = async (): Promise<GetOwnerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_owner: {}
    });
  };
}
export interface DsourceEmptyInterface extends DsourceEmptyReadOnlyInterface {
  contractAddress: string;
  sender: string;
  setState: ({
    language,
    parameters,
    scriptUrl
  }: {
    language?: string;
    parameters?: string[];
    scriptUrl?: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  setServiceFees: ({
    contractAddr,
    fee
  }: {
    contractAddr: HumanAddr;
    fee: Coin;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawFees: ({
    fee
  }: {
    fee: Coin;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  setOwner: ({
    owner
  }: {
    owner: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
}
/**
 * ```ts
 * const { contractAddress } = await client.deploy(
    admin,
    path.join(testDataDir, 'dsource_empty.wasm'),
    {
      language: 'node',
      script_url: 'https://gist.githubusercontent.com/tubackkhoa/4ab5353a5b44118ccd697f14df65733f/raw/4a27d2ac4255d23463286898b161eda87d1b95bb/datasource_coingecko.js',
      parameters: ['ethereum']
    } as DsourceEmptyTypes.InstantiateMsg,
    'dsource',
    'auto'
  );
  const dsourceContract = new DsourceEmptyClient(client, admin, contractAddress);
  ```
 */
export class DsourceEmptyClient extends DsourceEmptyQueryClient implements DsourceEmptyInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.setState = this.setState.bind(this);
    this.setServiceFees = this.setServiceFees.bind(this);
    this.withdrawFees = this.withdrawFees.bind(this);
    this.setOwner = this.setOwner.bind(this);
  }

  setState = async ({
    language,
    parameters,
    scriptUrl
  }: {
    language?: string;
    parameters?: string[];
    scriptUrl?: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_state: {
        language,
        parameters,
        script_url: scriptUrl
      }
    }, $fee, $memo, $funds);
  };
  setServiceFees = async ({
    contractAddr,
    fee
  }: {
    contractAddr: HumanAddr;
    fee: Coin;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_service_fees: {
        contract_addr: contractAddr,
        fee
      }
    }, $fee, $memo, $funds);
  };
  withdrawFees = async ({
    fee
  }: {
    fee: Coin;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_fees: {
        fee
      }
    }, $fee, $memo, $funds);
  };
  setOwner = async ({
    owner
  }: {
    owner: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_owner: {
        owner
      }
    }, $fee, $memo, $funds);
  };
}